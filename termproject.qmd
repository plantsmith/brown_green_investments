---
title: "Term Project"
format: html
editor: visual
---

```{r}
library(tidyverse)
library(here)
library(quantmod) #tools for modeling financial data
```

Start by defining the date range we'd like to model investments for.

```{r}
# Define the date range
start_date <- "2014-01-01"
end_date <- "2019-12-31"
```

Build portfolios of brown and green firms.

Brown firms include: Exxon Mobil (XOM), Chevron (CVX), BP (BP), ConocoPhillips (COP), and Shell (SHEL).

Green firms include: NextEra Energy (NEE), Tesla (TSLA), Enphase Energy (ENPH), Brookfield Renewable Partners (BEP), and First Solar (FSLR).

tickers = a unique, alphabetic code that identifies a company's stock or bond on a stock exchange

```{r}
brown_tickers <- c("XOM", "CVX", "BP", "COP", "SHEL")  # Fossil fuel companies
green_tickers <- c("NEE", "TSLA", "ENPH", "BEP", "FSLR")  # Renewable/green tech companies

```

```{r}
# Fetch data for the Brown Portfolio
#getSymbols = fetches historical stock data for these tickers from Yahoo Finance

for (ticker in brown_tickers) {
  getSymbols(ticker, src = "yahoo", from = start_date, to = end_date)
}

# Fetch data for the Green Portfolio
for (ticker in green_tickers) {
  getSymbols(ticker, src = "yahoo", from = start_date, to = end_date)
}
```

Merge the adjusted closing prices for all stocks in each portfolio into a single data frame.

Inputs & Variables:

Definition: lapply() is a function that applies a specified function over a list or vector and returns a list. In this case, our green and brown firms are the lists.

function(ticker) Ad(get(ticker)): get(ticker): This retrieves the data frame containing stock data for each ticker. This data includes various price types (Open, High, Low, Close, Volume, and Adjusted Close).

Ad(...): This extracts the Adjusted Close prices from the data frame returned by get(). The Adjusted Close prices are adjusted for dividends and stock splits, making them ideal for performance analysis.

call() is a function that allows you to call another function (in this case, merge()) with a list of arguments. Here, it merges multiple data frames into one.

merge(...): The merge() function combines the Adjusted Close price series for all tickers into a single data frame. Each stock's Adjusted Close prices are merged based on their date index, allowing for a side-by-side comparison of the stock prices across all tickers.

```{r}
# Combine Adjusted Close Prices for each portfolio
brown_prices <- do.call(merge, lapply(brown_tickers, function(ticker) Ad(get(ticker))))

green_prices <- do.call(merge, lapply(green_tickers, function(ticker) Ad(get(ticker))))

```

Calculate daily returns for each portfolio

```{r}
brown_returns <- na.omit(ROC(brown_prices, type = "discrete"))
green_returns <- na.omit(ROC(green_prices, type = "discrete"))

```

Calculates the daily returns for each portfolio using the Rate of Change (ROC) function. The na.omit function removes any missing values from the returns data.

ROC() Function:

Function Definition: Calculates the rate of change between the current price and the previous price.

Parameters: Input: Time series of prices (brown_prices and green_prices). type = "discrete": Specifies the method for calculating returns. When set to "discrete," it calculates the returns using the formula: $$
\text{Return} = \frac{P_t - P_{t-1}}{P_{t-1}} = \frac{P_t}{P_{t-1}} - 1
$$ where: Pt is the current price and Pt-1 is the previous price.

Calculate Annualized Mean Returns for Each Portfolio

Annual mean returns for each portfolio by taking the mean of the daily returns and multiplying by 252 (the approx. number of trading days in a year)

```{r}
# Calculate annualized mean returns for each portfolio
brown_avg_return <- mean(brown_returns) * 252
green_avg_return <- mean(green_returns) * 252

```

Set up variables for the model:

```{r}
# Set up initial variables
set.seed(123)  # For reproducibility
initial_investment <- 10000 # starting investment is 10k
n_scenarios <- 100  # Number of scenarios to simulate
n_months <- 60  # Simulation for 5 years (60 months)


```

# come here

Adjusted Standard Deviations for Monthly Returns

We need this step as it provides monthly volatility for each portfolio.

Volatility = the degree of variation in returns. A key measure of risk, and including it in the model reflects the reality that returns are not constant. By defining a standard deviation (volatility) for each portfolio, we can simulate random monthly returns.

The standard deviation of monthly returns is calculated by dividing the annual standard deviation by the square root of 12 (the number of months in a year). This adjustment accounts for the compounding effect of volatility over time. -- does this make sense?

-   figure out what the standard deviation of the monthly returns should be for each portfolio

```{r}
# adjusted standard deviations for monthly returns (update SD to reflect true SD)
brown_sd <- 0.02 / sqrt(12)   
green_sd <- 0.015 / sqrt(12)    

```

Create new data frame to hold results:

Variables:

-   Scenario: Scenario number
-   brown_allocation: Portion of investment in brown stocks
-   green_allocation: Portion of investment in green stocks
-   final_value: Final portfolio value after the simulation
-   total_return: Total return on investment
-   environmental_cost: Estimated environmental cost associated with the investment.

```{r}
results <- data.frame(
  scenario = integer(),
  brown_allocation = numeric(),
  green_allocation = numeric(),
  final_value = numeric(),
  total_return = numeric(),
  environmental_cost = numeric()
)
```

4 loops:

```{r}
# Run scenarios with a loop
for (i in 1:n_scenarios) {
  
  # Randomly allocate a portion to brown and the rest to green
  brown_allocation <- runif(1, 0, 1)    # Random allocation between 0 and 1
  green_allocation <- 1 - brown_allocation
  
  # Generate monthly returns for each portfolio type
  brown_monthly_returns <- rnorm(n_months, brown_avg_return / 12, brown_sd)
  green_monthly_returns <- rnorm(n_months, green_avg_return / 12, green_sd)
  
  # Calculate portfolio growth over time
  portfolio_value <- initial_investment
  for (j in 1:n_months) {
    # Update portfolio value with weighted returns for the month
    monthly_return <- (brown_monthly_returns[j] * brown_allocation) + 
      (green_monthly_returns[j] * green_allocation)
    portfolio_value <- portfolio_value * (1 + monthly_return)
  }
  
  # Calculate cumulative return and environmental impact
  total_return <- (portfolio_value - initial_investment) / initial_investment
  environmental_cost <- portfolio_value * brown_allocation * 0.1  # Adjusted emissions proxy based on final value
  
  # Store results
  results[i, ] <- c(
    scenario = i,
    brown_allocation = brown_allocation,
    green_allocation = green_allocation,
    final_value = portfolio_value,
    total_return = total_return,
    environmental_cost = environmental_cost
  )
}
  
```

Notes: 
- Loop runs through the number of scenarios defined earlier. For each iteration, it simulates an investment scenario
- Generates a random allocation for brown stocks between 0 and 1 using runif(1, 0, 1), and calculates the remaining portion for green stock
- Purpose: Simulates monthly returns for each portfolio using a normal distribution (rnorm):
n_months: Number of months in the simulation.
brown_avg_return / 12: Mean monthly return for brown stocks.
brown_sd: Standard deviation for brown stocks.
- Initializes the portfolio value to the initial investment and starts another loop to iterate through each month of the simulation.
- Calculates the weighted monthly return based on the allocations to each portfolio and updates the portfolio value accordingly.
-total_return: Calculates the total return on investment as a fraction of the initial investment.
-environmental_cost: Estimates the environmental cost based on the final portfolio value, assuming a 10% cost attributed to the brown allocation. 
  - what value should we use here?
  - do we have to have environmental cost here?
- store results amends the data frame you previous created

Results
```{r}
summary(results)
```
Plots:
return: amount of money that an investor makes or loses from their investment over some period of time
```{r}
#come back and make ggplots

# plot total return vs. brown portfolio allocation
plot(results$brown_allocation, results$total_return, 
     xlab = "Brown Portfolio Allocation", 
     ylab = "Total Return", 
     main = "Impact of Brown vs. Green Allocation on Returns")

# plot total return vs. green portfolio allocation
plot(results$green_allocation, results$total_return, 
     xlab = "Green Portfolio Allocation", 
     ylab = "Total Return", 
     main = "Impact of Brown vs. Green Allocation on Returns")

# plot environmental cost vs. brown portfolio allocation
plot(results$brown_allocation, results$environmental_cost, 
     xlab = "Brown Portfolio Allocation", 
     ylab = "Environmental Cost", 
     main = "Impact of Brown Allocation on Environmental Cost")

# plot environmental cost vs. green portfolio allocation
plot(results$green_allocation, results$environmental_cost, 
     xlab = "Brown Portfolio Allocation", 
     ylab = "Environmental Cost", 
     main = "Impact of Brown Allocation on Environmental Cost")



```


