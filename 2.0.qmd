---
title: "2.0"
description: "Utilize financial modeling tools and carbon accounting models to simulate investment returns and assess environmental impacts over a five-year period."
date: "2021-10-20"
format: 
  html:
    code-fold: false
    toc: true
    number-sections: true
    embed-resources: true
theme: Litera
editor: visual
execute:
  echo: true
  message: false
  warning: false
---

# Questions:

```{r}

# Load libraries
library(tidyverse)
library(quantmod)
library(dplyr)
library(ggplot2)

```

# Define Portfolios

1.  Define the date range for the investment model

```{r}
#define the date range
start_date <- "2018-01-01"
end_date <- "2023-12-31"
```

2.  Build portfolios of brown and green firms.

Brown firms include: Exxon Mobil (XOM), Chevron (CVX), BP (BP), ConocoPhillips (COP), and Shell (SHEL).

Green firms include: NextEra Energy (NEE), Tesla (TSLA), Enphase Energy (ENPH), Brookfield Renewable Partners (BEP), and First Solar (FSLR).

Carbon intensity was calculated by taking a company's total emissions across Scope 1, 2, and 3 for 2023 and dividing them by the company's revenue for the same period. Measured in tonnes of CO2 per unit of revenue

```{r}
# Define company tickers
tickers <- c("XOM", "CVX", "BP", "COP", "SHEL", "NEE", "TSLA", "ENPH", "BEP", "FSLR")

# Define carbon intensities for each company (in tonnes of CO2 per unit of revenue)
carbon_intensities <- c(
  XOM = 0.002,     # Exxon Mobil
  CVX = 0.0008,    # Chevron
  BP = 0.0002,     # BP
  COP = 0.0003,    # ConocoPhillips
  SHEL = 0.006,    # Shell
  NEE = 0.002,     # NextEra Energy
  TSLA = 0.002,    # UPDATE
  ENPH = 0.00003,  # Enphase Energy
  BEP = 0.000005,  # Brookfield Renewable Partners
  FSLR = 0.0013    # First Solar
)

# Social Cost of Carbon (SCC) in dollars per tonne of CO2
SCC <- 185
```

Cl(stock_data): Extracts the "Close" price (adjusted closing price) for each day from the stock_data object. dailyReturn(): This function calculates the daily returns based on the adjusted close prices. It computes the percentage change in the price from one day to the next.

Output: returns_list: A list containing daily returns for each company. volatility_list: A list containing the volatility (standard deviation) of returns for each company. price_data_list: A list containing the raw stock price data for each company.

```{r}
# Initialize empty lists to store data
returns_list <- list()
volatility_list <- list()
price_data_list <- list()

# Loop through each ticker to get financial data within the date range
for (ticker in tickers) {
  # Get financial data from Yahoo Finance with date range
  stock_data <- getSymbols(ticker, src = "yahoo", from = start_date, to = end_date, auto.assign = FALSE)
  
  # Calculate returns (percentage change from adjusted closing prices)
  returns <- dailyReturn(Cl(stock_data))  # 'Cl' extracts the adjusted closing prices
  returns_list[[ticker]] <- returns
  
  # Calculate volatility (standard deviation of daily returns)
  volatility <- sd(returns, na.rm = TRUE)  # Standard deviation of daily returns
  volatility_list[[ticker]] <- volatility
  
  # Store price data for further analysis if needed
  price_data_list[[ticker]] <- stock_data
}

```

```{r}
# Calculate average daily return for each company and annualize it
annual_returns <- sapply(returns_list, function(x) mean(x, na.rm = TRUE) * 252)

# Calculate daily volatility and convert to monthly volatility
sd_og <- sapply(returns_list, function(x) sd(x, na.rm = TRUE))  # Daily standard deviation
monthly_sd <- sd_og / sqrt(12)  # Adjusted standard deviations for monthly returns

# Add the annualized return and monthly volatility to the portfolio data frame
portfolio_data <- data.frame(
  company = tickers,
  carbon_intensity = carbon_intensities,
  return = sapply(returns_list, function(x) mean(x, na.rm = TRUE)),  # Average return over the date range
  volatility = monthly_sd,  # Monthly volatility
  environmental_cost = sapply(carbon_intensities, function(x) x * SCC),  # Environmental cost based on SCC
  annual_return = annual_returns  # Annualized return
)

# View the portfolio data
print(portfolio_data)


```

```{r}
# # print(returns_list)
# 
# #view specific company 
# returns_list[["XOM"]] 
# 
# # View the first few daily returns for each company
# lapply(returns_list, head)
# 
# # Get a summary of returns for each company (e.g., mean, min, max)
# lapply(returns_list, summary)


```

simulate different portfolio allocations to assess how different combinations of investments in "brown" and "green" firms affect the portfolioâ€™s performance in terms of returns, volatility, and carbon costs. The goal is to understand how the portfolio behaves under various scenarios based on random allocation of weights across the companies in the portfolio.

Each simulation involves generating a random allocation of investments across the companies. This means randomly assigning weights to each company's stock within the portfolio, where the sum of all weights in the portfolio equals 1 (100%)

```{r}
# Set initial investment and other parameters
initial_investment <- 10000  # Total investment amount
n_scenarios <- 100           # Number of scenarios
n_months <- 60               # Number of months (5 years)

# Set seed for reproducibility
set.seed(3)

# Data frame to store the simulation results
results <- data.frame(
  total_return = numeric(n_scenarios), 
  total_volatility = numeric(n_scenarios), 
  total_carbon_emissions = numeric(n_scenarios), 
  total_environmental_cost = numeric(n_scenarios), 
  total_investment = rep(initial_investment, n_scenarios)
)

# Portfolio simulation
for (i in 1:n_scenarios) {
  
  # Generate random allocation weights for each company
  allocation <- runif(length(tickers))
  allocation <- allocation / sum(allocation)  # Normalize to sum to 1
  
  # Generate annual returns for each company (using the annualized returns)
  annual_returns <- portfolio_data$annual_return
  monthly_returns <- matrix(rnorm(n_months * length(tickers), mean = annual_returns / 12, sd = monthly_sd), 
                            ncol = length(tickers))  # Matrix of monthly returns for each company
  
  # Initialize portfolio value
  portfolio_value <- initial_investment
  
  # Loop through months to simulate portfolio growth
  for (j in 1:n_months) {
    # Update portfolio value with weighted returns for the month
    weighted_returns <- monthly_returns[j, ] * allocation  # Monthly return for each asset
    portfolio_value <- portfolio_value * (1 + sum(weighted_returns))  # Update portfolio value
  }
  
  # Calculate cumulative return
  total_return <- (portfolio_value - initial_investment) / initial_investment
  
  # Calculate portfolio volatility (annualized)
  total_volatility <- sqrt(sum((allocation^2) * (portfolio_data$volatility^2))) 
  
  # Calculate total carbon emissions (based on allocation and emissions intensity)
  total_carbon_emissions <- sum(allocation * portfolio_data$carbon_intensity) * initial_investment
  
  # Calculate total environmental cost (based on allocation and environmental cost factor)
  total_environmental_cost <- sum(allocation * portfolio_data$environmental_cost) * initial_investment
  
  # Store the results of this scenario
  results[i, ] <- c(total_return, total_volatility, total_carbon_emissions, total_environmental_cost, initial_investment)
}

```

```{r}
# Plot financial returns vs environmental cost with volatility as size
ggplot(results, aes(x = total_environmental_cost, y = total_return, size = total_volatility)) +
  geom_point(alpha = 0.7) +
  labs(title = "Financial Returns vs Environmental Cost",
       x = "Environmental Cost (USD)",
       y = "Portfolio Return ($)",
       size = "Portfolio Volatility") +
  theme_minimal()

```

A scatter plot is created using ggplot2. x = carbon: Carbon intensity. y = return: Portfolio return. size = volatility: The size of the points represents the volatility of the portfolio. color = carbon_cost: The color of the points indicates the carbon cost associated with the portfolio. The plot helps visualize the trade-offs between carbon intensity, return, and the associated environmental costs.

```{r}
# # # Initialize results list to store each scenario's data before combining
# results_list <- vector("list", n_scenarios)
# 
# # Run scenarios to simulate random allocation
# for (i in 1:n_scenarios) {
#   allocation <- runif(length(tickers))  # Random allocation for each company
#   allocation <- allocation / sum(allocation)  # Normalize to sum to 1
#   
#   # Generate monthly returns for each company
#   company_monthly_returns <- matrix(rnorm(n_months * length(tickers), avg_return / 12, sd), 
#                                     nrow = n_months, ncol = length(tickers))
#   
#   # Initialize portfolio value and returns
#   portfolio_value <- initial_investment
#   monthly_portfolio_returns <- numeric(n_months)
#   
#   # Track individual company returns
#   company_final_returns <- numeric(length(tickers))
#   
#   # Calculate emissions and environmental costs
#   emissions <- initial_investment * allocation * emissions_intensity
#   environmental_cost_allocation <- emissions * SCC
#   
#   # Update portfolio value based on monthly returns and allocation
#   for (j in 1:n_months) {
#     # For each company, calculate individual company returns
#     company_returns_at_j <- company_monthly_returns[j, ]  # Returns for all companies at month j
#     company_final_returns <- company_final_returns + company_returns_at_j * allocation  # Accumulated return by company
#     
#     # Calculate portfolio monthly return
#     portfolio_monthly_return <- sum(company_returns_at_j * allocation)
#     portfolio_value <- portfolio_value * (1 + portfolio_monthly_return)
#     monthly_portfolio_returns[j] <- portfolio_monthly_return
#   }
#   
#   # Calculate cumulative return for individual companies
#   total_return <- (portfolio_value - initial_investment) / initial_investment
#   total_enviro_cost_scenario <- sum(environmental_cost_allocation)  # Total environmental cost
#   
#   # Store results for individual company returns and portfolio return
#   results_list[[i]] <- data.frame(
#     scenario = i,
#     company = tickers,
#     allocation = allocation,
#     final_portfolio_value = portfolio_value,
#     total_return = total_return,
#     company_final_return = company_final_returns,  # Store individual company returns
#     emissions = emissions,
#     environmental_cost_allocation = environmental_cost_allocation,
#     total_enviro_cost_scenario = total_enviro_cost_scenario  # Total environmental cost
#   )
# }
# 
# # Combine all results from all scenarios
# results <- do.call(rbind, results_list)


```

```{r}

# Initialize results list to store each scenario's data before combining
# results_list <- vector("list", n_scenarios)
# 
# # Run scenarios to simulate random allocation
# for (i in 1:n_scenarios) {
#   allocation <- runif(length(tickers))  # Random allocation for each company
#   allocation <- allocation / sum(allocation)  # Normalize to sum to 1
# 
#   # Generate monthly returns for the companies (using rnorm for each company)
#   company_monthly_returns <- matrix(rnorm(n_months * length(tickers), avg_return / 12, sd),
#                                     nrow = n_months, ncol = length(tickers))
#   portfolio_value <- initial_investment
#   monthly_portfolio_returns <- numeric(n_months)
# 
#   # Initialize a vector to store individual company volatilities
#   company_volatilities <- numeric(length(tickers))
# 
#   # Calculate emissions and environmental costs once per company
#   emissions <- initial_investment * allocation * emissions_intensity
#   environmental_cost_allocation <- emissions * SCC
# 
#   # Update portfolio value based on monthly returns and allocation
#   for (j in 1:n_months) {
#     # Calculate the total portfolio return for the month (weighted by allocation)
#     portfolio_monthly_return <- sum(company_monthly_returns[j, ] * allocation)
#     portfolio_value <- portfolio_value * (1 + portfolio_monthly_return)
#     monthly_portfolio_returns[j] <- portfolio_monthly_return  # Record the return for this month
#   }
# 
#   # Calculate cumulative return and total environmental cost
#   total_return <- (portfolio_value - initial_investment) / initial_investment
#   total_enviro_cost_scenario <- sum(environmental_cost_allocation)  # Renamed total environmental cost
# 
#   # Calculate volatility for each company (standard deviation of returns over time)
#   for (k in 1:length(tickers)) {
#     company_returns <- company_monthly_returns[, k]
#     company_volatility <- sd(company_returns) * sqrt(12)  # Annualize volatility
#     company_volatilities[k] <- company_volatility
#   }
# 
#   # Calculate portfolio (scenario) volatility based on weighted returns
#   portfolio_volatility <- sd(monthly_portfolio_returns) * sqrt(12)  # Annualize portfolio volatility
# 
#   # Store scenario results
#   results_list[[i]] <- data.frame(
#     scenario = i,
#     company = tickers,
#     allocation = allocation,
#     final_portfolio_value = portfolio_value,
#     total_return = total_return,
#     emissions = emissions,
#     environmental_cost_allocation = environmental_cost_allocation,
#     total_enviro_cost_scenario = total_enviro_cost_scenario,  # Renamed column
#     company_volatility = company_volatilities,  # Store volatility for each company
#     scenario_volatility = portfolio_volatility  # Store volatility for the entire scenario (portfolio)
#   )
# }
# 
# # Combine all scenarios into a single data frame
# results <- do.call(rbind, results_list)


```
