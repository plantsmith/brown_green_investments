---
title: "Term Project"
format: 
  html:
    code-fold: false
    toc: true
    number-sections: true
    embed-resources: true
theme: Litera
editor: visual
execute:
  echo: true
  message: false
  warning: false
---

# Questions:

-   What are the uncertainties in this model?
-   Should we be using the SCC in this model?
-   Maybe probability is accounted for in the model but randomly distributing the allocation of?
-   How to incorporate code?
-   How do we tie the environmental benefits into this?

```{r}
library(tidyverse)
library(here)
library(quantmod) #for modeling financial data
library(patchwork)
```

# Define Portfolios

1.  Define the date range for the investment model

```{r}
#define the date range
start_date <- "2014-01-01"
end_date <- "2019-12-31"
```

2.  Build portfolios of brown and green firms.

Brown firms include: Exxon Mobil (XOM), Chevron (CVX), BP (BP), ConocoPhillips (COP), and Shell (SHEL).

Green firms include: NextEra Energy (NEE), Tesla (TSLA), Enphase Energy (ENPH), Brookfield Renewable Partners (BEP), and First Solar (FSLR).

```{r}
# #create vectors based on brown and green tickers
brown_tickers <- c("XOM", "CVX", "BP", "COP", "SHEL")  # Fossil fuel companies
green_tickers <- c("NEE", "TSLA", "ENPH", "BEP", "FSLR")  # Renewable/green tech companies

```

```{r}
# brown_tickers <- c("XOM", "CVX", "BTU", "RTNTF", "BAYRY")  # Fossil fuel companies
# green_tickers <- c("TSLA", "HGLD", "DNNGY", "BYND","UL")  # Sustainable companies
```

```{r}
# # #create vectors based on brown and green tickers
# brown_tickers <- c("XOM", "CVX", "BP", "COP", "SHEL", "BTU", "RTNTF", "BAYRY" )  # Fossil fuel companies
# green_tickers <- c("NEE", "TSLA", "ENPH", "BEP", "FSLR", "BYND","HGLD", "UL")  # Renewable/green tech/sustainable companies
```

```{r}
#get data to build portfolios
#getSymbols = fetches historical stock data for these tickers from Yahoo Finance

for (ticker in brown_tickers) {
  getSymbols(ticker, src = "yahoo", from = start_date, to = end_date)
}

# Fetch data for the Green Portfolio
for (ticker in green_tickers) {
  getSymbols(ticker, src = "yahoo", from = start_date, to = end_date)
}
```

3.  Merge the adjusted closing prices for all stocks in each portfolio into individual data frames

**lapply(brown_tickers, function(ticker) Ad(get(ticker))):**

-   `lapply()` iterates over each ticker in brown_tickers.

-   For each ticker, the function `get(ticker)` retrieves the stock data (including Open, High, Low, Close, Volume, and Adjusted Close prices).

-   `Ad()` then extracts just the Adjusted Close price for each stock, creating a list of Adjusted Close prices for each ticker in the brown portfolio.

**do.call(merge, ...):**

-   `do.call()` applies the merge function across the list of Adjusted Close prices created by `lapply()`.

-   merge combines these individual Adjusted Close prices into a single data frame (`brown_prices`) where each column represents one stock’s Adjusted Close price, with dates aligned across all stocks.

Adjusted Closing Prices: An adjusted closing price (ACP) is a modified closing price that takes into account events that impact a stock's value, such as dividends, stock splits, and rights offerings. The ACP is a more accurate representation of a stock's value than the closing price, which only shows what investors paid for shares at the end of a trading day. Insight to how the stock has changed over time.

```{r}
# Combine adjusted closing prices for each portfolio
brown_prices <- do.call(merge, lapply(brown_tickers, function(ticker) Ad(get(ticker))))

green_prices <- do.call(merge, lapply(green_tickers, function(ticker) Ad(get(ticker))))

```

4.  Calculate daily returns for each portfolio

-   **Daily return =** The calculated daily returns for each stock in the portfolio represent the percentage change in the stock's price from one day to the next. Each entry in the daily returns data frame shows the percentage change between the Adjusted Close price of one day and the previous day. Insight into daily performance. Daily returns are essential for calculating volatility.

```{r}
brown_returns <- na.omit(ROC(brown_prices, type = "discrete"))
green_returns <- na.omit(ROC(green_prices, type = "discrete"))


```

Calculates the daily returns for each portfolio using the Rate of Change (ROC) function.

**Function Definition:** The `ROC()` function calculates the rate of change (returns) between the current price and the previous price in a time series.

**Parameters:**

-   **Input:** The function takes a time series of prices as input, specifically the data frames `brown_prices` and `green_prices`, which contain the Adjusted Close prices for the respective portfolios.

-   **Type:** The parameter `type = "discrete"` specifies the method of return calculation. When set to "discrete," the function computes returns using the following formula:

$$
    \text{Return} = \frac{P_t - P_{t-1}}{P_{t-1}} = \frac{P_t}{P_{t-1}} - 1
$$

where:

-   Pt is the current price (Adjusted Close price at time t)
-   Pt-1 is the previous price (Adjusted Close price at time t-1)

5.  Calculate Annualized Mean Returns for Each Portfolio

Find the annual mean returns for each portfolio by taking the mean of the daily returns and multiplying by 252 (the approx. number of trading days in a year)

```{r}
#calculate annualized mean returns for each portfolio
brown_avg_return <- mean(brown_returns) * 252
green_avg_return <- mean(green_returns) * 252


```

6.  Adjusted Standard Deviations for Monthly Returns

The standard deviations for monthly returns are calculated by dividing the annual standard deviation by the square root of 12. This adjustment reflects the compounding effect of volatility over time, as it translates annual risk into a monthly context. By defining the standard deviation for each portfolio, we account for the reality that returns fluctuate, which is essential for simulating random monthly returns and assessing potential risks associated with the investments.

The standard deviation of monthly returns is calculated by dividing the annual standard deviation by the square root of 12 (the number of months in a year). This adjustment accounts for the compounding effect of volatility over time. -- does this make sense?

-   **figure out what the standard deviation of the monthly returns should be for each portfolio**

```{r}
#adjusted standard deviations for monthly returns (update SD to reflect true SD)
brown_sd_og <- sd(brown_returns)
green_sd_og <- sd(green_returns)

brown_sd <- brown_sd_og / sqrt(12)   
green_sd <- green_sd_og / sqrt(12)    

```

# Set up the For Loop

7.  Specify variables for the model:

```{r}
#set up initial variables
set.seed(123)  #for reproducibility
initial_investment <- 10000 # starting investment is 10k
n_scenarios <- 1000  #number of scenarios to simulate
n_months <- 60  #simulation for 5 years (60 months)

```

8.  Create new data frame to hold results:

Variables:

-   Scenario: Scenario number
-   Brown_allocation: Portion of investment in brown stocks
-   Green_allocation: Portion of investment in green stocks
-   Final_value: Final portfolio value after the simulation
-   Total_return: Total return on investment

```{r}
results <- data.frame(
  scenario = integer(),
  brown_allocation = numeric(),
  green_allocation = numeric(),
  final_value = numeric(),
  total_return = numeric()
)
```

9.  Create a loop to run 100 investing scenarios over a 5 year time period:

-   Each loop represents a unique investment scenario characterized by different random allocations and returns. For each iteration, a random allocation for brown stocks is generated using `runif(1, 0, 1)`, while the remaining portion is allocated to green stocks.

-   The simulation models monthly returns for each portfolio using a normal distribution with parameters:

    -   `n_months` (the total number of months)

    -   `brown_avg_return / 12` (the mean monthly return for brown stocks)

    -   `brown_sd` (the standard deviation for brown stocks)

-   The portfolio value is initialized to the initial investment, followed by a nested loop that iterates through each month of the simulation for a total of 60 months. During each month, the weighted monthly return is calculated based on the portfolio allocations, and the portfolio value is updated.

-   The total return on investment is computed as a fraction of the initial investment, giving us insights into the portfolio's performance over time.

```{r}
#run scenarios with a loop
#loop repeats until i equals n_scenarios (100)

for (i in 1:n_scenarios) {
  
  #randomly allocate a portion to brown and the rest to green
  brown_allocation <- runif(1, 0, 1)    # Random allocation between 0 and 1
  green_allocation <- 1 - brown_allocation
  
  #generate monthly returns for each portfolio type
  brown_monthly_returns <- rnorm(n_months, brown_avg_return / 12, brown_sd)
  green_monthly_returns <- rnorm(n_months, green_avg_return / 12, green_sd)
  
  #calculate portfolio growth over time
  #j starts at 1 and goes up to n_months (60).
  portfolio_value <- initial_investment
  for (j in 1:n_months) {
    # Update portfolio value with weighted returns for the month
    monthly_return <- (brown_monthly_returns[j] * brown_allocation) + 
                      (green_monthly_returns[j] * green_allocation)
    portfolio_value <- portfolio_value * (1 + monthly_return)
  }
  
  #calculate cumulative return
  total_return <- (portfolio_value - initial_investment) / initial_investment
  
  #update results df
  results <- rbind(results, data.frame(
    scenario = i,
    brown_allocation = brown_allocation,
    green_allocation = green_allocation,
    final_value = portfolio_value,
    total_return = total_return
  ))
}
  
```

```{r}
summary(results)
```

11. Visualize the portfolio allocation

```{r}
# Plot total return vs. brown portfolio allocation
brown_plot <- ggplot(results, aes(x = brown_allocation, y = total_return)) +
  geom_point(color = "peachpuff4") +
  labs(
    title = "Impact of Brown Allocation on Returns",
    x = "Brown Portfolio Allocation",
    y = "Total Return" 
  ) +
  theme_minimal()

brown_plot

# Plot total return vs. green portfolio allocation
green_plot <- ggplot(results, aes(x = green_allocation, y = total_return)) +
  geom_point(color = "springgreen4") +
  # geom_smooth(sd = FALSE) +
  labs(
    title = "Impact of Green Allocation on Returns",
    x = "Green Portfolio Allocation",
        # y = NULL) +  # Remove y-axis label
    y = "Total Return") +
  theme_minimal()

green_plot



```

Some sort of environmental aspect:
Use an emissions factor to estimate average CO₂ emissions per dollar invested in different sectors

```{r}
# calculate_environmental_cost <- function(brown_allocation, 
#                                          green_allocation, 
#                                          # Define parameters that won't change
#                                          initial_investment = 10000, 
#                                          emissions_factor_brown = 0.001, 
#                                          emissions_factor_green = 0.0003, 
#                                          SCC = 185) {
#   
#   # Calculate emissions
#   brown_emissions <- initial_investment * brown_allocation * emissions_factor_brown
#   green_emissions <- initial_investment * green_allocation * emissions_factor_green
#   
#   # Total emissions and environmental cost
#   total_emissions <- brown_emissions + green_emissions
#   environmental_cost <- total_emissions * SCC
#   
#   return(environmental_cost)
# }
# 
# 
# # Example usage of the function
# brown_allocation <- 0
# green_allocation <- 1
# 
# environmental_cost <- calculate_environmental_cost(brown_allocation, green_allocation)
# print(environmental_cost)

```

^^^^ this didnt work how I wanted it to

```{r}
# Parameters for environmental impact (amended code from above)
SCC <- 185  # Social Cost of Carbon in USD per tonne (this could be updated as needed)
emissions_factor_brown <- 0.001  # Emissions factor for brown investments: tonnes CO₂ per dollar invested
emissions_factor_green <- 0.0003  # Emissions factor for green investments: tonnes CO₂ per dollar invested

# Initialize an empty data frame for storing results including environmental impacts
results <- data.frame(
  scenario = integer(),
  brown_allocation = numeric(),
  green_allocation = numeric(),
  final_value = numeric(),
  total_return = numeric(),
  brown_emissions = numeric(),
  green_emissions = numeric(),
  total_emissions = numeric(),
  environmental_cost = numeric()
)

#run the scenarios
for (i in 1:n_scenarios) {
  
#randomly allocate a portion to brown and the rest to green
  brown_allocation <- runif(1, 0, 1)  # Random allocation between 0 and 1
  green_allocation <- 1 - brown_allocation
  
#generate monthly returns for each portfolio type
  brown_monthly_returns <- rnorm(n_months, brown_avg_return / 12, brown_sd)
  green_monthly_returns <- rnorm(n_months, green_avg_return / 12, green_sd)
  
#initialize portfolio value
  portfolio_value <- initial_investment
  for (j in 1:n_months) {
    # Update portfolio value with weighted returns for the month
    monthly_return <- (brown_monthly_returns[j] * brown_allocation) + 
                      (green_monthly_returns[j] * green_allocation)
    portfolio_value <- portfolio_value * (1 + monthly_return)
  }
  
#calculate cumulative return
  total_return <- (portfolio_value - initial_investment) / initial_investment
  
#calculate emissions based on allocation
  brown_emissions <- initial_investment * brown_allocation * emissions_factor_brown
  green_emissions <- initial_investment * green_allocation * emissions_factor_green
  total_emissions <- brown_emissions + green_emissions
  
#calculate environmental cost (social cost of carbon)
  environmental_cost <- total_emissions * SCC
  
#update results data frame
  results <- rbind(results, data.frame(
    scenario = i,
    brown_allocation = brown_allocation,
    green_allocation = green_allocation,
    final_value = portfolio_value,
    total_return = total_return,
    brown_emissions = brown_emissions,
    green_emissions = green_emissions,
    total_emissions = total_emissions,
    environmental_cost = environmental_cost
  ))
}

#results
summary(results)

```

```{r}

#plot it
brown_environmental_cost_plot <- ggplot(results, aes(x = brown_allocation, y = environmental_cost)) +
  geom_line(color = "peachpuff4", size = 1) +  # Use a line instead of points
  labs(
    title = "Impact of Brown Allocation on Environmental Cost",
    x = "Brown Portfolio Allocation",
    y = "Environmental Cost"
  ) +
  theme_minimal()

brown_environmental_cost_plot


green_environmental_cost_plot <- ggplot(results, aes(x = green_allocation, y = environmental_cost)) +
  geom_line(color = "springgreen4", size = 1) +  # Use a line instead of points
  labs(
    title = "Impact of Green Allocation on Environmental Cost",
    x = "Green Portfolio Allocation",
    y = "Environmental Cost"
  ) +
  theme_minimal()

green_environmental_cost_plot
```



-   1\. Sector-Specific Emissions factor Data

    Many organizations and studies provide emissions intensity data by sector, measured in tonnes of CO₂ per unit of revenue, production, or value invested. High-emissions sectors typically include energy (especially fossil fuels), utilities, materials, and transportation, while green sectors often include renewable energy, technology with low environmental impact, and environmentally-focused industries.

    You could use emissions intensity data to estimate average CO₂ emissions per dollar invested in different sectors:

    The International Energy Agency (IEA) and Environmental Protection Agency (EPA) publish sectoral emissions intensity data.

    Carbon Disclosure Project (CDP) and Sustainalytics also provide emissions reports, often aggregated by sector.

-   Large companies, especially public companies, publish **annual sustainability or ESG reports** with data on their total CO₂ emissions (Scope 1, 2, and sometimes 3 emissions).

-   To find emissions per dollar invested, take the company’s total emissions and divide it by its market capitalization or revenue.

-   For example, if a company in the energy sector emits 10 million tonnes of CO₂ annually and has a market cap of \$100 billion, you might calculate an approximate emissions rate of 100,000,000,000dollars/10,000,000tonnes​=0.0001tonnes CO₂ per dollar invested.
